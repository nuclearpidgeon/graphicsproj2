1. What the application does,

The application, titled 'Chase', is a game that aims to make the most of the different input methods afforded by the use of a tablet PC. The player controls a rolling ball that is placed at the start of a level made up of different level pieces. The goal is to guide the ball towards the end zone in a timely manner whilst amassing a flock of friendly 'boids'. Boids of different types are scattered throughout the level and it is your job have friendly boids join your flock whilst also protecting your flock from enemy boids that will try to attack it. Boids may need to be collected/rescued from difficult/dangerous situations - this is complicated by the fact that other boids in your flock will want to come with you and as such, having a large flock makes it more dangerous to attempt to collect boids from risky location. To complete a level, bring as many friendly boids as you can to the end zone and coerce them into the end zone target. As the world is fully simulated, particular world elements may be interacted with in a natural manner. For instance, to protect your flock from enemies, you can fling, with a swipe gesture, an enemy boid away (or a friendly boids to safety). Physics puzzles along the course can be interacted with in the same way, such as tipping a draw-bridge or destroying a stack of blocks that block your path. The accelerometer is used to control the player's rolling ball in a way that is physically realistic with appreciable inertia and friction.

2. How to use it (especially the user interface aspects)

The main menu interface offers a range of selectable options from a brief instruction section which has a fiew pages, that can be swiped through, demonstrating briefly the game interface.
On selecting "Play" from the main menu, the user will be presented with a list of levels to play. Select a level and it will load. You will see the follow-camera centered on the player.
To control the main player, use either the keyboard (for desktop) or the accelerometer (with the tablet PC placed on a flat, upwards-facing surface to be the resting position) to apply force to the player causing it to roll in the desired direction. Carefully navigate the level to collect boids. To interact with physics entities in the world, pick them with your mouse or finger (for touch-screen) and flick/drag/drop them and notice that they behave in a realistic way.
To pause the game, press the 'Z' key (or 'ESC') if using a keyboard, otherwise swipe your finger onto the screen from the top screen edge to reveal a menu bar with options to un-pause, restart the level or return to the main menu.

3. How you modelled objects and entities,

Objects are modeled structurally as a hierarchical manner, deriving from a GameObject class and then objects with physical properties, a PhysicsObject class and then concrete instantiations from there.
The modeling of the flocking boids properties was handled by a Flock class that controls all boids present in a level and allows introspection of the flock from the perspective of other boids (useful to find other like-boids or for enemies to hunt others, etc).
Each game level contains a list of LevelPieces which represent the physical structure of the world, a list of important entities such as the player and the camera and a flock to control the level boids. Each LevelPiece represents a large "tile" in the game world, of which many are stitched together to construct the playing course. Each LevelPiece contains a list of child entities that comprise its layout (such as walls, barriers and the floor for that piece) as well as a list of PhysicsPuzzles. A PhysicsPuzzle is a setup or arangement of some PhysicsObjects in a particular manner to create a particular effect (such as a stack of blocks to create a brick wall). These PhysicsPuzzles are instantiated upon a particular level piece with a given position relative to the piece. This gives us an easy to build with way of creating larger scale structures and complexitiy in the levels by instantiation of these pieces (e.g. bricks are laid out in a wall relative to each other, and then this wall is placed on a level piece relative to its coordinates, which is placed in some position in the larger level).

Update and Render are called on the game's current level, which calls these methods on its children, which call it on their children, etc. In this manner, an implicit scene graph is achieved.

Game service components are modeled through the GameComponent interfaces of SharpDX. We use this for things like handling input (InputSystem), connection between our graphical representation and the physically simulated world representation of objects (PhysicsSystem) as well as user interface state from the XAML side of things for game options, etc (PersistantStateManager).

Physically, objects were modeled in Blender with some application of Maya to create tangent-space coordinates in our 3D models, as required by our shading routine.

4. How you handled graphics and camera motion, and

We encountered some unforseen issues with getting our custom shaders to work due our use of tangent-space coordinates in models and difficulty in debugging shaders. Most of our world's models are rendered using the BasicEffect passed into the model's Draw method.

For testing, a DebugDrawer class was implemented that allows the physics simulation to draw its internal representation of world entities. World entities are usually expressed in the Physics world as a simpler regular polygon (a ball mesh bounding a model) or a convex-hull shape for efficiency reasons. To ensure that our physical representation was congruent with our rendred representation, we can enable this "DebugDraw" mode to draw a white, wireframe mesh of what the physics system calculates the object's state to be.

Camera motion is implemented as 3rd person "follow" camera, that can be provided with a GameObject (in this case, the player) to follow, as well as an offset vector which describes where and how far behind the camera should stay.

5. A statement about any code/APIs you have sourced/used from the internet that is not your own.

Our project makes use of a customised version of the Jitter Physics library. Jitter Physics is a pure C# barebones 3D physics library built on the .Net platform and license under the zLib license. We encountered an issue when building our application for the Windows Store in that referenced libraries available for all platforms using the Portable .Net framework, which is the minimum subset of supported .Net framework when all applicable devices are considered (this subset is extremely minimal). The portable framework made inaccessable a lot of the .Net framework that Jitter is built around, so we rebuilt most of it using the portable subset. The result is Jitter Portable, our derivative and renamed (zLib requires it) pure C# 3D physics library targeting the Portable .Net framework. The end result is that our application can pass store validation and theoretically be built to target desktops, tablets, ARM/WinRT devices, Windows Phone and the Silverlight web runtime too. We plan to release Jitter Portable for public use at a later date.
